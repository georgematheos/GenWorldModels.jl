abstract type LookupTable{K, V} end

"""
    __lookup__!(l::LookupTable, idx)
Returns the index `idx` from the LookupTable. For internal use only.
"""
function __lookup__!(l::LookupTable)
    error("Not implemented")
end

# TODO: make this a UUID generated by
# the UsingMemoized combinator for safety when we have
# nested `UsingMemoized` calls
__idx_lookup_addr__(l::LookupTable) = :__LOOKED_UP_IDX__

# a lookup table which already has all its values filled in
struct ConcreteLookupTable{K, V} <: LookupTable{K, V}
    table::Dict{K, V}
end
__lookup__!(c::ConcreteLookupTable, idx) = getindex(c.table, idx)
    
mutable struct MemoizedGenFn{Tr <: Gen.Trace, K, V} <: LookupTable{K, V} 
    gen_fn::GenerativeFunction{V, Tr}
    subtraces::PersistentHashMap{K, Tr}
    lookup_counts::PersistentHashMap{K, Int}
    total_score::Float64
end

# empty memoized gen fn with no decisions yet
# by default set K = Any
function MemoizedGenFn(gen_fn::GenerativeFunction{V, Tr}) where {V, Tr}
    MemoizedGenFn{Tr, Any, V}(gen_fn, PersistentHashMap{Any, Tr}(), PersistentHashMap{Any, Int}(), 0.)
end

"""
    generate_memoized_gen_fn_with_known_vals(gen_fn::GenerativeFunction, known_idx_vals::ChoiceMap)

Create a `MemoizedGenFn` for `gen_fn` with every `idx` in `keys(get_submaps(known_idx_vals))`
pre-populated with a value obtained by `generate`ing `gen_fn` with constraint submap
`get_submap(known_idx_vals, idx)`.
Return `(mgf, weight)` where `mgf` is the `MemoizedGenFn`, and
`weight` is the total weight from generating all the values.
"""
function generate_memoized_gen_fn_with_prepopulated_indices(gen_fn::GenerativeFunction{V, Tr}, known_idx_vals::ChoiceMap) where {V, Tr}
    mgf = MemoizedGenFn(gen_fn)
    total_weight = 0.
    for (idx, constraints) in get_submaps_shallow(known_idx_vals)
        total_weight += __generate_value__!(mgf, idx, constraints)
    end
    mgf, total_weight
end

"""
    __lookup__!(mgf::MemoizedGenFn{Tr, K, V}, idx::L) where {Tr, K, V, L<:K}
    
Looks up `idx` in `mgf`.  If no value exists for the index, generates one.
Increments the lookup count for `idx` in `mgf`.
"""
function __lookup__!(mgf::MemoizedGenFn{Tr, K, V}, idx::L) where {Tr, K, V, L<:K}
    if !haskey(mgf.subtraces, idx)
        # TODO: if there is nonaddressed randomness, we may need to track the weight from this
        __generate_value__!(mgf::MemoizedGenFn, idx)
    end
    mgf.lookup_counts = assoc(mgf.lookup_counts, idx, mgf.lookup_counts[idx] + 1)
    return get_retval(mgf.subtraces[idx])
end

function __generate_value__!(mgf::MemoizedGenFn, idx, constraints::ChoiceMap)
    @assert !haskey(mgf.subtraces, idx)
    @assert !haskey(mgf.lookup_counts, idx)
    
    tr, weight = generate(mgf.gen_fn, (idx,), constraints)
    mgf.subtraces = assoc(mgf.subtraces, idx, tr)
    mgf.lookup_counts = assoc(mgf.lookup_counts, idx, 0)
    mgf.total_score += get_score(tr)
    # TODO: noise?
    
    return weight
end

__generate_value__!(mgf::MemoizedGenFn, idx) = __generate_value__!(mgf::MemoizedGenFn, idx, EmptyChoiceMap())

# similar to __generate_value__!, except nonmutating
function __generate__(mgf::MemoizedGenFn, idx, constraints)
    @assert !haskey(mgf.subtraces, idx)
    @assert !haskey(mgf.lookup_counts, idx)
    
    tr, weight = generate(mgf.gen_fn, (idx,), constraints)
    new_subtraces = assoc(mgf.subtraces, idx, tr)
    new_lookup_counts = assoc(mgf.lookup_counts, idx, 0)
    new_total_score = mgf.total_score + get_score(tr)
    
    MemoizedGenFn(mgf.gen_fn, new_subtraces, new_lookup_counts, new_total_score), weight
end

__total_score__(mgf::MemoizedGenFn) = mgf.total_score

function __get_choices__(mgf::MemoizedGenFn)
    cm = choicemap()
    for (idx, tr) in mgf.subtraces
        set_submap!(cm, idx, get_choices(tr))
    end
    return cm
end

function __has_value__(mgf::MemoizedGenFn, idx)
    haskey(mgf.subtraces, idx)
end

function __update__(mgf::MemoizedGenFn, idx, constraints::ChoiceMap)
    new_subtrace, weight, retdiff, discard = update(mgf.subtraces[idx], (idx,), (NoChange(),), constraints)
    new_mgf = MemoizedGenFn(
        mgf.gen_fn,
        assoc(mgf.subtraces, idx, new_subtrace),
        mgf.lookup_counts,
        mgf.total_score - get_score(mgf.subtraces[idx]) + get_score(new_subtrace)
    )
    
    (new_mgf, weight, retdiff, discard)
end

function __decrease_count__!(mgf::MemoizedGenFn, idx, by_amount)
    mgf.lookup_counts = assoc(mgf.lookup_counts, idx, mgf.lookup_counts[idx] - by_amount)
    return mgf.lookup_counts[idx]
end
__decrease_count__!(_::ConcreteLookupTable, _, _) = nothing

function __delete_idx__!(mgf, idx)
    subtrace = mgf.subtraces[ids]
    mgf.subtraces = dissoc(mgf.subtraces, idx)
    return subtrace
end

struct MemoizedGenFnDiff{K} <: Gen.Diff
    updated_indices_to_retdiffs::Dict{K, Diff}
    new_indices::Set{K}
end