abstract type LookupTable{K, V} end

"""
    __getindex__(l::LookupTable, idx)
Returns the index `idx` from the LookupTable. For internal use only.

For a `MemoizedGenFn`
"""
function __getindex__(l::LookupTable)
    error("Not implemented")
end

# TODO: make this a UUID generated by
# the UsingMemoized combinator for safety when we have
# nested `UsingMemoized` calls
__idx_lookup_addr__(l::LookupTable) = :__LOOKED_UP_IDX__

# a lookup table which already has all its values filled in
struct ConcreteLookupTable{K, V} <: LookupTable{K, V}
    table::Dict{K, V}
end
__getindex__(c::ConcreteLookupTable, idx) = getindex(c.table, idx)
    
mutable struct MemoizedGenFn{Tr <: Gen.Trace, K, V} <: LookupTable{K, V} 
    gen_fn::GenerativeFunction{V, Tr}
    subtraces::Dict{K, Tr}
    total_score::Float64
end

# empty memoized gen fn with no decisions yet
function MemoizedGenFn(gen_fn::GenerativeFunction{V, Tr}) where {V, Tr}
    MemoizedGenFn(gen_fn, Dict{Any, Tr}(), 0.)
end

"""
    generate_memoized_gen_fn_with_known_vals(gen_fn::GenerativeFunction, known_idx_vals::ChoiceMap)

Create a `MemoizedGenFn` for `gen_fn` with every `idx` in `keys(get_submaps(known_idx_vals))`
pre-populated with a value obtained by `generate`ing `gen_fn` with constraint submap
`get_submap(known_idx_vals, idx)`.
Return `(mgf, weight)` where `mgf` is the `MemoizedGenFn`, and
`weight` is the total weight from generating all the values.
"""
function generate_memoized_gen_fn_with_prepopulated_indices(gen_fn::GenerativeFunction{V, Tr}, known_idx_vals::ChoiceMap) where {V, Tr}
    mgf = MemoizedGenFn(gen_fn)
    total_weight = 0.
    for (idx, constraints) in get_submaps_shallow(known_idx_vals)
        total_weight += __generate_value__!(mgf, idx, constraints)
    end
    mgf, total_weight
end

function __getindex__(mgf::MemoizedGenFn{Tr, K, V}, idx::L) where {Tr, K, V, L<:K}
    if !haskey(mgf.subtraces, idx)
        __generate_value__!(mgf::MemoizedGenFn, idx)
    end
    return get_retval(mgf.subtraces[idx])
end

function __generate_value__!(mgf::MemoizedGenFn, idx, constraints::ChoiceMap)
    tr, weight = generate(mgf.gen_fn, (idx,), constraints)
    mgf.subtraces[idx] = tr
    mgf.total_score += get_score(tr)
    # TODO: noise?
    
    return weight
end

__generate_value__!(mgf::MemoizedGenFn, idx) = __generate_value__!(mgf::MemoizedGenFn, idx, EmptyChoiceMap())

__total_score__(mgf::MemoizedGenFn) = mgf.total_score

function __get_choices__(mgf::MemoizedGenFn)
    cm = choicemap()
    for (idx, tr) in mgf.subtraces
        set_submap!(cm, idx, get_choices(tr))
    end
    return cm
end